<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="write something">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen Haonan&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Chen Haonan&#39;s Notes">
<meta property="og:description" content="write something">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen Haonan&#39;s Notes">
<meta name="twitter:description" content="write something">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Chen Haonan's Notes</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chen Haonan's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/13/OOP面向对象编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/13/OOP面向对象编程/" itemprop="url">OOP面向对象编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T21:51:07+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面向对象编程是一种基于以”对象”为概念的编程范式，它可以使用字段包含数据，可以使用方法来包含程序。对象的一个功能是他们的方法是对外暴露的，通常情况下可以使用这些方法去改变数据。在面向对象编程中，计算机程序被设计成一个个相互交互的模型。OOP语言是多种多样的，但是最流行的一种是基于class的面向对象，在这种语言中对象是类的实例，当我们拿到一个对象时，我们能够知道他所属的类型。</p>
<p>许多广泛使用的编程语言例如C++、JAVA、Python都是多范式的编程语言，他们在或多或少支持面向对象编程的同时还支持命令式和过程式编程。主要的面向对象语言包括Java, C++, C#, Python, PHP, JavaScript, Ruby, Perl, Object Pascal, Objective-C, Dart, Swift, Scala, Common Lisp, MATLAB, and Smalltalk.</p>
<h3 id="与非面向对象语言相同的部分"><a href="#与非面向对象语言相同的部分" class="headerlink" title="与非面向对象语言相同的部分"></a>与非面向对象语言相同的部分</h3><ul>
<li>基本的逻辑结构</li>
<li>基本数据类型</li>
<li>内置数据结构 List Hash</li>
<li>方法 函数</li>
<li>模块化编程 支持模块引入</li>
</ul>
<h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><p>支持面向对象的编程语言使用继承做到对代码的复用，可以继承自类也可以继承自原型对象。基于类的面向对象语言主要包含以下两种概念</p>
<ul>
<li>Class 定义了指定类型中的数据和可用的代码</li>
<li>Object 基于类的实例</li>
</ul>
<p>基于类的面向对象语言中的组成</p>
<ul>
<li>Class variables</li>
<li>Instance variables</li>
<li>Member variables</li>
<li>Class methods</li>
<li>Instance methods</li>
</ul>
<h3 id="基于类-VS-基于原型"><a href="#基于类-VS-基于原型" class="headerlink" title="基于类 VS 基于原型"></a>基于类 VS 基于原型</h3><p>在基于类的语言中，需要先定义类，通过类实例化对象，而在基于原型的语言中对象是主要的实体，没有类的存在，对象之间通过prototype互相连接，每一个对象都有且只有一个原型，当对象被创建的时候会绑定一个原型对象，当访问对象上的属性的时候首先在对象本身访问，如果不存在则会一次寻找原型对象，通过原型只能够实现单继承。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>保护数据不被滥用和损坏，所有的数据改变都是可控的。</p>
<h3 id="组合-继承-代理"><a href="#组合-继承-代理" class="headerlink" title="组合 继承 代理"></a>组合 继承 代理</h3><p>has-a is-a use？</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>基于同一个父类派生的多个子类可以重新父类的方法 在调用的时候能够做到与特定子类型无关的同时会别使用各自实现的方法从而实现关注点的分离。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>单一职责</li>
<li>开放封闭</li>
<li>里氏替换</li>
<li>接口隔离</li>
<li>依赖倒置</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/合理使用react的生命周期/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/合理使用react的生命周期/" itemprop="url">合理使用React的生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-06T17:41:50+08:00">
                2018-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大家在写React代码的时候也就是在React的生命周期函数中编写代码，有的时候我们在两个生命周期中编写代码可能得到的是相同的结果，但是对于生命周期的使用是有最佳实践的。</p>
<p>特别是在React v16.3之后引入了异步渲染的概念，这个时候我们如何使用生命周期就变得更加重要了，首先我们先来看看v16.3之前的生命周期</p>
<h2 id="React-v16-3以前的生命周期"><a href="#React-v16-3以前的生命周期" class="headerlink" title="React v16.3以前的生命周期"></a>React v16.3以前的生命周期</h2><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwyq3wa6h8j30fq09zgm6.jpg" alt="react hocks beforev16.3"></p>
<h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">	<span class="keyword">super</span>(props)</span><br><span class="line">	<span class="keyword">this</span>.state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数阶段，只调用一次，接收到传入的props，需要手动调用super(props)</p>
<p>在这个阶段我们对组件的state数据进行初始化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		...</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>render阶段 这个阶段我们渲染UI<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">	<span class="keyword">const</span> container = <span class="keyword">this</span>.DomContainer</span><br><span class="line">	<span class="keyword">const</span> containerHeight = container.clientHeight</span><br><span class="line">	<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">		containerHeight</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UI渲染完毕的阶段，只调用一次，在这个生命周期开始DOM才被创建，一些jquery库需要在这里初始化，如果需要计算DOM的高度来初始化，那么也应该在这里进行初始化</p>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>更新分为两种：一种是父组件传入的props变化，或者组件调用setState()</p>
<p>当props发生变化时进入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们可以更新组件的state，但是最好是根据组件的props计算后去渲染UI，因为这样可以保证单一数据源又避免维护一份数据产生额外的开销</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个boolean值，表示是否应该更新，默认返回true，返回false时不再执行下面的生命周期</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		...</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line">componentDidUpdate() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>render声明周期前后分别是componentWillUpdate和componentDIdUpdate</p>
<p>更新的第二种是组件调用forceUpdate，这时候会直接进入componentWillUpdate</p>
<h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件在页面卸载之前进入componentWillUnmount生命周期，在这里我们可以对需要清理的资源资源进行释放，比如：清除计时器</p>
<h2 id="Reactv16-3开始的生命周期"><a href="#Reactv16-3开始的生命周期" class="headerlink" title="Reactv16.3开始的生命周期"></a>Reactv16.3开始的生命周期</h2><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwyqkzfryjj30va0hqtb5.jpg" alt="react hocks afterv16.3"></p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ul>
<p>这些生命周期方法经常被错误的使用，当开启异步渲染的时候可能存在安全隐患</p>
<p>所以16.3版本开始 这些生命周期将增加UNSAFE_开头的别名 </p>
<p>17.0版本开始将删除这些生命周期 只有UNSAFE_开头的生命周期可以使用</p>
<p>新增俩个生命周期getDerivedStateFromProps和getSnapshotBeforeUpdate </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个生命周期替换了componentWillReceiveProps的所有情况，接收到nextProps和prevState，返回一个state对象merge到原来的state</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个生命周期替换了componentWillUpdate，返回的对象将作为第三个参数传给componentDidUpdate</p>
<p>除了这俩个生命周期的变化，还提出了三个阶段的概念，render阶段，pre-commit阶段和commit阶段，由于要支持异步渲染，所以组件的生命周期可能由于优先级更高的事件触发而终止，<br>在render阶段我们可以终止组件继续渲染。<br>在pre-commit阶段我们可以对dom的数据进行读取。<br>在commit阶段我们可以使用dom，执行副作用操作。</p>
<ol>
<li>添加事件监听<br>componentWillMount 和 componentWillUnmount 不是一对生命周期<br>只有调用了componentDidMount 才一定会调用 componentWillUnmount<br>所以如果在componentWillMount中做了一些比如注册监听的工作<br>由于component 在没有完成componentDidMount的时候可能会被打断<br>所以也不会执行 componentWillUnmount 中的清理工作 It can leak<br>所以我们应该把注册监听的操作放到componentDidMount中执行<br>这样就保证我们在componentWillUnmount中的清理工作一定会被执行 </li>
<li><p>获取外部数据<br>在componentWillMount中大家可能会去获取外部数据<br>使得数据会再componentDIdMount的时候正确的渲染<br>但实际上这是做不到的<br>在执行完componentWillMount之后会立刻执行componentDidMount<br>这是一个同步执行的过程 而从接口获取数据是一个异步的过程<br>所以提前到componentWillMount中执行是没有意义的 </p>
</li>
<li><p>初始化数据<br>componentWillMount 中初始化数据的操作应该迁移到constructor中 </p>
</li>
<li><p>componentWIllUpdate 和 componentDidUpdate<br>当组件更新时需要产生副作用 使用componentDidUpdate 而不是componentWillUpdate<br>在异步模式下 多次willUpdate可能只会触发一次真正的更新所以在willUpdate中产生副作用可能达不到你想要的预期 </p>
</li>
<li><p>getSnapshotBeforeUpdate(prevProps, prevState)<br>使用componentWillUpdate读取dom属性对于异步渲染来说<br>componentWillUpdate 和 render 属于 render 生命周期<br>与 componentDidUpdate 之间存在延迟<br>如果在这个时间内用户改变了dom 存储的数据将会失效<br>解决的方法就是使用getSnapshotBeforeUpdate方法 </p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/08/React中的事件模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/08/React中的事件模型/" itemprop="url">React中的事件模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-08T10:18:15+08:00">
                2018-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与浏览器原生的事件不同React中的事件属于合成事件，是由React提供的，首先我们看一下浏览器原生的事件模型</p>
<h3 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h3><p>DOM事件分为三个阶段</p>
<ol>
<li>事件捕获</li>
<li>事件目标处理函数</li>
<li>事件冒泡</li>
</ol>
<p>当事件触发的时候，首先由document发出一个事件流，通过DOM树一层层到达目标DOM这个阶段属于事件捕获，到达触发事件DOM这个阶段是执行处理函数，接下来从目标DOM返回到document这个阶段称为事件冒泡阶段。</p>
<p>一般情况下我们的事件处理函数在事件冒泡阶段执行，addEventListener API的第三的参数接收一个boolean值 允许我们制定事件是否在捕获阶段执行，默认是false。</p>
<p>我们可以调用 event.stopPorpagation()来组织事件冒泡 IE下使用 event.cancel = true</p>
<p>使用事件对于浏览器来说是一个相对来说比较消耗性能的操作，而且当绑定事件的DOM从页面中移除的时候我们需要手动接触事件监听以防止出现内存泄漏的问题。</p>
<p>当一个列表中的每一个item都需要绑定事件的时候，如果每一个item都绑定事件就不是一个好的方法，一来我们需要对多个事件监听进行绑定和移除，二来多个事件监听浪费了更多的内存影响浏览器性能。</p>
<p>解决方法就是使用事件委托思想，利用事件冒泡机制，在所有item的外层添加一个事件处理函数，然后根据event对象的target属性来判断真实触发事件的DOM，这样就只需要一个事件处理函数，降低了维护成本，也提高了页面的性能。</p>
<p>事件委托也存在局限的地方因为是依赖事件冒泡原理实现的，但是有些事件是不支持事件冒泡的，那么这些事件也就无法使用代理机制。</p>
<hr>
<h3 id="React中的合成事件"><a href="#React中的合成事件" class="headerlink" title="React中的合成事件"></a>React中的合成事件</h3><p>React将所有类型的事件绑定到document上，使用全局统一的事件监听器，这个事件监听器维护了所有React事件和处理函数的映射关系，当组件绑定事件时，就会在这个映射关系上插入一个对象，当组件卸载时，在这个映射关系上删除一个对象，这样就不会频繁的绑定和卸载事件监听，只需要维护这个映射关系就可以了。</p>
<p>当触发事件时，我们知道事件的类型和触发事件的React component，我们找到这个React component，如果事件是支持冒泡的，那我们还需要findParent找到它的父节点，这个过程一直重复到parent是document，然后事件就沿着这个路线一直到document，当然我们也可以使用event.stopPropagation()阻止事件冒泡，因为event对象经过封装所以stopPropagation方法在IE下也可以使用没有兼容性问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/react出现的意义及设计理念/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/react出现的意义及设计理念/" itemprop="url">React出现的意义及设计理念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T20:33:13+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="传统开发框架存在的问题"><a href="#传统开发框架存在的问题" class="headerlink" title="传统开发框架存在的问题"></a>传统开发框架存在的问题</h2><ul>
<li>Jquery式的开发框架采用命令式的编程范式 需要关注DOM的细节</li>
<li>数据变化后 UI的同步变得非常困难</li>
<li>大量的API增加学习成本 降低了开发效率</li>
<li>数据模型中Model与View之间复杂的依赖关系</li>
</ul>
<h2 id="React设计理念"><a href="#React设计理念" class="headerlink" title="React设计理念"></a>React设计理念</h2><ul>
<li>采用函数式编程范式 应用的每一个状态对应一个页面的UI 不需要关注DOM细节</li>
<li>每次生成的Virtual DOM 都是全量渲染 不需要区分是否是更新状态</li>
<li>组件化思想 将整个页面抽象成一个组件 组件之间的相互嵌套组成了整个页面</li>
<li>极少的API和声明周期函数 理解了这些就可以进行应用的开发</li>
<li>采用Flux架构，单项数据流 保证了每次数据变化都是可追踪的</li>
</ul>
<h2 id="React-使用JSX将HTML和JS混合在一起？"><a href="#React-使用JSX将HTML和JS混合在一起？" class="headerlink" title="React 使用JSX将HTML和JS混合在一起？"></a>React 使用JSX将HTML和JS混合在一起？</h2><p>首先将html和js分成不同文件只是将他们分开管理而并非在逻辑上“分而治之”<br>React的组件作为一个完成特定功能的组件具有高内聚的特性是极为重要的<br>而且在React中使用onClick是完全区别于在html中使用onclick</p>
<p>在html中使用onclick有什么缺点呢？</p>
<ol>
<li>onclick添加的事件处理函数是在全局环境下执行的，这会污染全局环境，造成意想不到的后果</li>
<li>给DOM添加事件处理函数 会降低程序的性能</li>
<li>DOM销毁的时候绑定的事件处理函数需要被手动销毁，忘记销毁可能会产生内存泄漏</li>
</ol>
<p>以上的几个问题在JSX中是不存在的</p>
<ol>
<li>JSX中的onClick使用的是事件委托的方式 只在最外层的DOM上注册一个事件处理函数 所有点击事件都触发这一个函数 然后根据组件来分配特定的函数</li>
<li>React的组件控制着生命周期 当组件销毁的时候 所有注册的事件处理函数也随之销毁</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/14/节流和防抖/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/节流和防抖/" itemprop="url">节流和防抖</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T11:39:00+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么我们需要节流和防抖？"><a href="#为什么我们需要节流和防抖？" class="headerlink" title="为什么我们需要节流和防抖？"></a>为什么我们需要节流和防抖？</h2><p>JavaScript遵循事件驱动的编程模型，用户的某些特定的行为会触发响应的回调函数，行为发生的频率是由用户控制的，频繁的触发回调函数可能会产生性能问题，这个时候我们可以从控制如何响应回调函数入手去优化性能。<br>考虑如下真实的场景：<br>一个图片墙功能，需要我们延迟加载图片，这就需要我们去监听页面滚动事件，在回调函数中我们判断未加载的图片当前是否展示在了浏览器可视区域，如果展示了，就去加载页面的真实地址。如果不对响应函数进行处理的话，scroll事件会频繁的计算图片的位置和当前滚动的位置，产生页面卡顿的现象。<br>一个input搜索功能，当用户从键盘输入内容的时候，向后端接口请求所有匹配的内容，类似于百度搜索栏一样的功能，如果我们不对响应函数加以控制，会出现什么现象呢？我们每输入一个字符，就都会向后端发出一次请求，但其实我们一次完整的输入过程并没有完成，这些中间状态是不必要的，请求接口也造成了资源的浪费。<br>处理以上情况通常的做法是使用节流和防抖。</p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>拿自来水管中的水流为例，节流的意思是降低水流的大小，用在这个地方是降低了响应响应时间的频率，限制了两次响应的时间间隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line"><span class="keyword">var</span> timeId = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> dur = <span class="number">1000</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'log'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'emit'</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">		clearTimeout(timeId)</span><br><span class="line">		<span class="keyword">if</span> (now - start &gt;= dur) &#123;</span><br><span class="line">			log()</span><br><span class="line">			start = now</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			timeId = setTimeout(log, dur)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle()</span><br></pre></td></tr></table></figure>
<p>这样的话我们就实现了节流的效果 这里我们每隔一秒钟响应一次 如果两次触发回调的时间间隔小于一秒我们就可以设置一个一秒钟的定时器这样就可以保证不会错误的丢掉响应 具体的时间间隔可以适当进行调整 这里只是做一个演示。</p>
<p>上面的代码实现了我们想要的功能但是从可用性角度来看是无法接受的，throttle函数依赖了全局的start和timeId变量并且与响应函数也存在强耦合的关系，下面我们稍微修改一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, dur</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">	<span class="keyword">var</span> timeId = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">		clearTimeout(timeId)</span><br><span class="line">		<span class="keyword">if</span> (now - start &gt;= dur) &#123;</span><br><span class="line">			fn()</span><br><span class="line">			start = now</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			timeId = setTimeout(fn, dur)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'log'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(log, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖这个术语在电学中是将多个电信号合并成一个电信号<br>在这里我们接收到一个响应信号时不是立即执行处理函数而是等待一定时间，如果这段时间内没有接收到信号则执行处理函数，如果再次接收到了那么重置开始时间重新等待，这样就可以做到在一定时间间隔内将多个信号合并<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'log'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, dur</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> timeId = <span class="literal">null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		clearTimeout(timeId)</span><br><span class="line">		timeId = setTimeout(fn, dur)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(log, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<p>有些时候我们需要先执行一次处理函数然后再进行等待<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'log'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immediate</span>(<span class="params">fn, dur</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> timeId = <span class="literal">null</span></span><br><span class="line">	<span class="keyword">var</span> timeout = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(timeout) &#123;</span><br><span class="line">			fn()</span><br><span class="line">			timeout = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			clearTimeout(timeId)</span><br><span class="line">			timeId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				fn()</span><br><span class="line">				timeout = <span class="literal">true</span></span><br><span class="line">			&#125;, dur)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = immediate(log, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>节流和防抖的概念在性能优化中是处理浏览器回调函数的常见手段，对提升我们页面性能和用户体验来说非常重要，还可以减少中间状态时不必要的请求，是非常重要的概念。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/01/浏览器安全/xss和csrf/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/浏览器安全/xss和csrf/" itemprop="url">xss和csrf</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-01T22:12:14+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h2><p>XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/前端性能优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/前端性能优化/" itemprop="url">前端性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T14:48:45+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>性能优化的必要性？<br>随着web应用复杂的的提升，性能问题使我们作为前端开发者不得不去关注的一个地方同时也是一个很重要的方面，因为网站的打开速度直接关系到客户留存率，页面打开时间每多一秒就会有很多的客户流失，从而造成直接的经济损失，特别是对于体量特别大的网站，每损失1%用户都是巨额经济损失，良好的性能能提高用户体验，提高用户的满意度，提高转化率，所以我们一定要重视网站的性能。</p>
<p>性能优化可以大体上分为加载性能优化和渲染性能优化</p>
<h3 id="加载性能优化"><a href="#加载性能优化" class="headerlink" title="加载性能优化"></a>加载性能优化</h3><ul>
<li>文本内容 对HTML、CSS、JS 进行minifier 去掉空格、注释、并且对JS中的变量进行替换以减小文件的大小</li>
<li>GZIP压缩 服务器开启GIZP后文本文件可以达到减小70%以上的效果（对图片的影响不大）</li>
<li>尽量不要依赖比较大的库，比如：jQuery，使用更轻量的方法替换引入整个库。</li>
<li>图片<ol>
<li>减少不必要图片的使用</li>
<li>选择合适的图片类型</li>
<li>删除图像元数据</li>
<li>适当降低图片的质量</li>
<li>裁剪图片仅显示重要内容 </li>
<li>压缩图片</li>
<li>加载合适大小的图片</li>
</ol>
</li>
<li>CSS文件合并 chrome浏览器对同一个域下的同时发出的请求数量限制六个，也就是说如果当页面首次加载的时候，我同时发出10个请求，那么其中4个请求就会等待，所以有些时候我们需要将静态文件合并以减少请求的数量</li>
<li>CSS雪碧图 合并图片请求</li>
<li>将JavaScript文件放置在文件末尾防止加载JS文件延迟页面渲染</li>
<li>部分页面渲染的JS代码可以放到HTML文件中，而不是发出一个额外的请求</li>
<li>使用CDN去提供静态资源服务</li>
<li>使用缓存<ol>
<li>Expires http1.0出现 设置对象的有效期 局限性：存在本地时间与服务器时间不一致</li>
<li>last-modified http1.0 设置最后修改时间在请求时带上本地Cache的last-modified web server 接到请求后check 如果和服务器上的last-modified相同则返回本地cache 否则返回最新修改的局限性：同一秒修改多次</li>
<li>E-tag http1.1 if-none-match</li>
<li>Cache-Control http1.1<br> max-age = num(s) 设置最大缓存时间<br> private 不会被多个用户共享<br> public 会被多个用户共享<br> no-cache 不会缓存<br> no-store 不会存储</li>
</ol>
</li>
<li>本地缓存<ol>
<li>localStroage</li>
<li>sessionStroage</li>
<li>indexedDB</li>
</ol>
</li>
</ul>
<h3 id="渲染性能优化"><a href="#渲染性能优化" class="headerlink" title="渲染性能优化"></a>渲染性能优化</h3><ul>
<li>WebAssembly</li>
<li>throttle debounce</li>
<li>修改DOM的时候使用类名控制避免重复layout</li>
<li>减少DOM的复杂度</li>
<li>lazyload preload</li>
<li>大列表优化</li>
<li>MTU base64 inline</li>
<li>小图 转换成 大图</li>
<li>progressive vs baseline</li>
<li>http 2.0</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/25/如何测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/25/如何测试/" itemprop="url">如何测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-25T22:54:44+08:00">
                2017-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>为什么大家都需要单元测试？</p>
<ul>
<li>代码质量持续有保障</li>
<li>重构正确性保障</li>
<li>增强自信心</li>
<li>自动化运行</li>
</ul>
<h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><h3 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a>mocha</h3><p>mocha的功能丰富 支持在node环境和浏览器环境下运行 异步的支持也很友好</p>
<h2 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>使用简单 反馈信息明确</p>
<h3 id="should-js"><a href="#should-js" class="headerlink" title="should.js"></a>should.js</h3><p>链式操作 功能强大</p>
<h2 id="开始实践"><a href="#开始实践" class="headerlink" title="开始实践"></a>开始实践</h2><p>全局安装mocha</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mocha -g</span><br></pre></td></tr></table></figure>
<p>也可以选择安装在项目中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install macha -s</span><br></pre></td></tr></table></figure>
<p>mocha会对你test文件夹下的js文件进行测试<br>项目目录</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fioueaeyhyj30hc0ogdgx.jpg" alt=""></p>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 引入需要的依赖 这里的断言库选择assert</span><br><span class="line">var assert = require(&apos;assert&apos;)</span><br><span class="line">// describe 代表你要对哪个对象的哪个方法进行测试 可以嵌套</span><br><span class="line">describe(&apos;Array&apos;, function() &#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function() &#123;</span><br><span class="line">  	 // it 代表测试的具体case</span><br><span class="line">    it(&apos;should return -1 when the value is not present&apos;, function() &#123;</span><br><span class="line">      assert.equal(-1, [1, 2, 3].indexOf(0))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fioum74y69j311u0b23zo.jpg" alt=""></p>
<h3 id="在浏览器中进行测试"><a href="#在浏览器中进行测试" class="headerlink" title="在浏览器中进行测试"></a>在浏览器中进行测试</h3><h4 id="karam"><a href="#karam" class="headerlink" title="karam"></a>karam</h4><p>安装依赖<br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fiouxhcalnj30ks07aaaz.jpg" alt=""></p>
<p>初始化测试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">karam init</span><br></pre></td></tr></table></figure>
<p>具体参数设置查询<a href="http://karma-runner.github.io/1.0/index.html" target="_blank" rel="noopener">karam官网</a></p>
<h1 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h1><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。</p>
<ul>
<li>快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li>
<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li>
</ul>
<h3 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h3><p>github上的项目 你托管在github上的项目可以使用它来进行集成测试<br><a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a></p>
<p>登陆你的github账号</p>
<p>开启对项目的检测<br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fiowf9ry90j31kw0l9tci.jpg" alt=""></p>
<p>这样你在push request代码的时候Travis CI会对项目进行自动的集成测试</p>
<p>项目目录<br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fiowi5zb7aj31ka0imaem.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>编写测试是一个很好的习惯</p>
<ul>
<li>有助于我们理清代码的思路</li>
<li>维护我们的代码质量</li>
<li>提高开发效率</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/浏览器安全/跨域问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/浏览器安全/跨域问题/" itemprop="url">跨域问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T19:32:08+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为一名前端，在日常开发的过程中我们使用ajax请求获取数据，我们常常会遇到跨域的问题，结合自己的实践和网上的资料，对浏览器的同源策略，解决跨域问题的常见方法进行总结。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>Q: 为什么我们需要同源?</p>
<p>A: 因为安全性的考虑。比如我们在登陆一个网站时留下的个人信息，证明身份的用户信息，登录的cookie信息，如果没有同源策略的限制别人就会很容易拿到这些信息，用户的安全性也就无法保障了。<br>Q: 怎么才算同源？</p>
<p>A: 协议相同 域名相同 端口相同</p>
<p>Q: 同源策略限制了哪些信息？</p>
<p>A: (0) Cookie、LocalStorage、IndexDB<br>    Cookie表明了用户的身份 LocalStorage、IndexDB也可能包含用户的信息<br>    (1) DOM 无法获得<br>    DOM？？？ 为什么DOM也无法获得呢？<br>    因为如果有一个伪装的网站在iframe中引入你真正要访问的网站 在子iframe中父级页面获得DOM元素后可以对ta进行事件的监听能够获得用户输入的密码等<br>    (2) AJAX 请求无法发送<br>  请求中的 cookie 会存储在浏览器客户端本地当 AJAX请求发出时会根据请求的域名带上 cookie 信息，如果没有同源策略限制就可以在恶意的页面中发起请求</p>
<h2 id="源的更改"><a href="#源的更改" class="headerlink" title="源的更改"></a>源的更改</h2><p>在我们需要在父域和子域之间进行正常的通信的时候，我们可以将父域和子域中的 document.domain 设置为父域，这样这两个页面会被当成同源。</p>
<h2 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h2><p>同源策略对我们来说是必要的，但是有些合理的数据传递也被限制了，但是我们还是能够通过一些其他的手段来间接的传递数据</p>
<h3 id="0-怎么做呢？"><a href="#0-怎么做呢？" class="headerlink" title="0.怎么做呢？"></a>0.怎么做呢？</h3><p>src属性具有天生跨域的能力 所以带有src属性的元素比如script iframe img 都不受同源策略的影响</p>
<h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>JSONP和JSON有什么关系？</p>
<p>JSON是自从AJAX2.0以来使用最广泛的数据传输格式 [] 表示 数组 {} 表示 对象<br>JSONP是一种数据的传输方式<br>所以说关系好像 JAVA 和 JavaScript(就是没啥关系)</p>
<p>那我们如何使用JSONP请求数据呢?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line"><span class="comment">// 前端接到数据后的处理函数</span></span><br><span class="line"><span class="built_in">window</span>.xxx = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src设置为要请求的url在参数上传出给后端的参数 这个参数是你和后端规定好的可以是任意</span></span><br><span class="line">script.src = <span class="string">'http://x.stuq.com:7001/json?callback=xxx'</span></span><br><span class="line"><span class="comment">//在后端接到这个callback的值也就是你要执行处理数据的方法名</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 然后返回给前端</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h3 id="2-CROS"><a href="#2-CROS" class="headerlink" title="2.CROS"></a>2.CROS</h3><p>设置Access-Control-Allow-Origin</p>
<p>第一种.将你需要跨域的站点设置上’Access-Control-Allow-Origin’, ‘<a href="http://xx.stuq.com&#39;" target="_blank" rel="noopener">http://xx.stuq.com&#39;</a><br>第二种.对所有站点的请求都不拦截’Access-Control-Allow-Origin’, ‘*’<br>这样设置之后就不用做任何事情了<br>参数还可以根据请求的站点动态设置，这样就保证了灵活性</p>
<h3 id="3-location-hash"><a href="#3-location-hash" class="headerlink" title="3.location.hash"></a>3.location.hash</h3><p>使用iframe 在iframe中加载一个与邀请同域的页面 在这个页面中发起请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个iframe</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line"><span class="comment">//加载一个同域的页面 我们在这个页面发ajax</span></span><br><span class="line">iframe.src = <span class="string">'http://x.stuq.com:7001/public/hash.html'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line"><span class="comment">// 进入hash.html这个页面</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="built_in">JSON</span>.parse(xhr.responseText)</span><br><span class="line">        parent.location.href = <span class="string">`http://y.stuq.com:7001/public/3.html#msg=<span class="subst">$&#123;res.msg&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://x.stuq.com:7001/json'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 监听hash改变事件 取得信息</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hash = location.hash</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/[#&amp;][^#&amp;]+=[^#&amp;]+/g</span></span><br><span class="line">  <span class="keyword">let</span> arr = hash.match(reg)</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tempArr = item.substring(<span class="number">1</span>).split(<span class="string">'='</span>)</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">decodeURIComponent</span>(tempArr[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">decodeURIComponent</span>(tempArr[<span class="number">1</span>])</span><br><span class="line">    obj[key] = val</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Window-name"><a href="#4-Window-name" class="headerlink" title="4.Window.name"></a>4.Window.name</h3><p>开始也是与上面一样<br>不同的地方在于在iframe中请求到数据后如何带回来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个iframe</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line"><span class="comment">//加载一个同域的页面 我们在这个页面发ajax</span></span><br><span class="line">iframe.src = <span class="string">'http://x.stuq.com:7001/public/name.html'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line"><span class="keyword">var</span> times = <span class="number">0</span></span><br><span class="line"><span class="comment">// 监听iframe的onload事件当页面每两次加载时取数据</span></span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++times === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(iframe.contentWindow.name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进入name.html这个页面</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    	<span class="comment">//使用window.name将数据保存</span></span><br><span class="line">        <span class="built_in">window</span>.name = xhr.responseText</span><br><span class="line">        <span class="comment">//跳回和parent页面同源的页面</span></span><br><span class="line">        location.href = <span class="string">'http://y.stuq.com:7001/public/index.html'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://x.stuq.com:7001/json'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-HTML5-的psotmessage"><a href="#5-HTML5-的psotmessage" class="headerlink" title="5.HTML5 的psotmessage"></a>5.HTML5 的psotmessage</h3><p>开始也是与上面一样<br>不同的地方在于在iframe中请求到数据后如何带回来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个iframe</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line"><span class="comment">// 加载一个同域的页面 我们在这个页面发ajax</span></span><br><span class="line">iframe.src = <span class="string">'http://x.stuq.com:7001/public/post.html'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line"><span class="comment">// 监听message事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(e.data))</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 进入post.html这个页面</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    	<span class="comment">// 第一个参数是传递的数据 第二个参数是那些页面可以接收到信息 * 表示所有 如果确切知道被谁使用 应该设置好具体的值</span></span><br><span class="line">        parent.postMessage(xhr.responseText, <span class="string">'*'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://x.stuq.com:7001/json'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-document-domain"><a href="#6-document-domain" class="headerlink" title="6. document.domain"></a>6. document.domain</h3><p>当二级域名相同可以分别对 a.test.com/index.html 和 b.test.com/index.html 设置 document.domain = test.com<br>这样两个页面会当成同域处理</p>
<h2 id="技术的适用场景"><a href="#技术的适用场景" class="headerlink" title="技术的适用场景"></a>技术的适用场景</h2><ul>
<li>最省力 设置Access-Control-Allow-Origin 为 * 但是不安全 不适用于比较私密的信息</li>
<li>后端能控制 则使用JSONP</li>
<li>后端无法控制 允许上传一个页面 window.name location.hash postMessage(前提是现代浏览器…)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/13/JavaScript中的继承/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Haonan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen Haonan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/13/JavaScript中的继承/" itemprop="url">JavaScript中的继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-13T15:23:53+08:00">
                2017-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JavaScript中的继承"><a href="#JavaScript中的继承" class="headerlink" title="JavaScript中的继承"></a>JavaScript中的继承</h2><p>JavaScript中的继承主要使用原型链实现<br>1.原型继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SuperType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> SubType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"></span><br><span class="line">instance.getSuperValue()</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> SuperType</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> SuberType</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>优点：实现了继承<br>缺点：实例之间的属性共享问题<br>2.借用构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">'tom'</span>, <span class="string">'petter'</span>, <span class="string">'li'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	Person.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance0 = <span class="keyword">new</span> Parent(<span class="string">'tony'</span>)</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Parent(<span class="string">'bruce'</span>)</span><br><span class="line"></span><br><span class="line">instance0.friends</span><br><span class="line"><span class="comment">// ['tom', 'petter', 'li']</span></span><br><span class="line">instance1.friends</span><br><span class="line"><span class="comment">// ['tom', 'petter', 'li']</span></span><br><span class="line"></span><br><span class="line">instance0.friends.push(<span class="string">'bob'</span>)</span><br><span class="line">instance1.friends.push(<span class="string">'bill'</span>)</span><br><span class="line"></span><br><span class="line">instance0.friends</span><br><span class="line"><span class="comment">// ['tom', 'petter', 'li', 'bob']</span></span><br><span class="line">instance1.friends</span><br><span class="line"><span class="comment">// ['tom', 'petter', 'li', 'bill']</span></span><br></pre></td></tr></table></figure></p>
<p>优点：实例之间的属性可以独立<br>缺点：实例之间的方法无法复用</p>
<p>3.组合继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">'tom'</span>, <span class="string">'petter'</span>, <span class="string">'li'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	Person.call(<span class="keyword">this</span>, name)</span><br><span class="line">	<span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Parent.prototype.constructor = Person</span><br><span class="line">Parent.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优点：不同的实例拥有各自的属性和相同的方法<br>缺点：调用两次构造函数</p>
<p>4.原型式继承<br>这是一种借助已有对象来进行继承的方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	F.prototype = o</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">var</span> person = &#123;</span><br><span class="line">        name: <span class="string">"Nicholas"</span>,</span><br><span class="line">        friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person)</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person)</span><br><span class="line"></span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>)</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>)</span><br><span class="line">person.friends   </span><br><span class="line"><span class="comment">// Shelby,Court,Van,Rob,Barbie</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript 5 新增 Object.create() 规范化原型式继承<br>优点：使用方便<br>缺点：使用属性的值会共享</p>
<p>5.寄生式继承<br>寄生式继承和寄生构造函数一样，都是在函数的内部对实例进行增强<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createAnother = <span class="function"><span class="keyword">function</span> (<span class="params">original</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(original)</span><br><span class="line">	clone.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHello()</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure></p>
<p>6.寄生组合继承<br>组合继承存在调用两次父类的构造函数问题这会时父类的原型上创建出多余的属性 解决的方案是 我们只需要父类原型一个拷贝 没有必要调用父类的构造方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype)</span><br><span class="line">    prototype.constructor = subType</span><br><span class="line">    subType.prototype = prototype</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]</span><br><span class="line">&#125; </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优点： 完美了</p>
<h2 id="以上"><a href="#以上" class="headerlink" title="以上"></a>以上</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen Haonan</p>
              <p class="site-description motion-element" itemprop="description">write something</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Haonan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
